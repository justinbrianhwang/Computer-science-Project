# All About Software Engineering

## Introduction

This directory contains organized notes and materials summarizing the book **"All About Software Engineering"** by **Choi Eun-man**. The purpose of this project is to provide a helpful resource for students to study software engineering more efficiently and effectively.

## Table of Contents

### **CHAPTER 01: Introduction**
1.1 Software
- 1.1.1 Types of Software
- 1.1.2 Systems

1.2 Software Development Tasks
- 1.2.1 Basic Activities
- 1.2.2 Characteristics of Development Tasks

1.3 Approaches to Software Engineering
- 1.3.1 Definition of Software Engineering
- 1.3.2 Goals of Software Engineering

1.4 Topics in Software Engineering
- 1.4.1 Phased Processes
- 1.4.2 Quality Assurance
- 1.4.3 Project Management

1.5 Related Fields
- 1.5.1 Related Knowledge Areas
- 1.5.2 Software Engineering and Computer Science

**■ Exercises**

### **CHAPTER 02: Processes and Methodologies**
2.1 Software Life Cycle

2.2 Processes
- 2.2.1 Types of Processes
- 2.2.2 Definition of Processes
- 2.2.3 Characteristics of Good Processes

2.3 Process Models
- 2.3.1 Waterfall Model
- 2.3.2 Prototyping Model
- 2.3.3 Spiral Model
- 2.3.4 Evolutionary Model
- 2.3.5 Unified Process
- 2.3.6 Agile Processes

2.4 Supporting Processes
- 2.4.1 Management Processes
- 2.4.2 Quality Assurance Processes
- 2.4.3 Configuration Management Processes

2.5 Methodologies
- 2.5.1 Structured Methodologies
- 2.5.2 Information Engineering Methodologies
- 2.5.3 Object-Oriented Methodologies

**■ Exercises**

### **CHAPTER 03: Project Planning and Management**
3.1 Project Initiation
- 3.1.1 Project Value
- 3.1.2 Project Risk
- 3.1.3 Feasibility Analysis

3.2 Project Planning and Scheduling
- 3.2.1 Setting Objectives
- 3.2.2 Project Scope
- 3.2.3 Work Breakdown Structure (WBS)
- 3.2.4 Scheduling

3.3 Cost Estimation Techniques
- 3.3.1 COCOMO-81
- 3.3.2 COCOMO II
- 3.3.3 Function Points

3.4 Project Team Organization
- 3.4.1 Team Roles
- 3.4.2 Functional Organization
- 3.4.3 Project-Based Organization
- 3.4.4 Matrix Organization
- 3.4.5 Agile Organization

3.5 Execution and Monitoring
- 3.5.1 Project Execution
- 3.5.2 Project Monitoring
- 3.5.3 Burn Down Chart

3.6 Risk Management
- 3.6.1 Identifying Risks
- 3.6.2 Risk Assessment
- 3.6.3 Risk Management

**■ Exercises**

### **CHAPTER 04: Requirements Analysis**
4.1 Requirements
- 4.1.1 Functional Requirements
- 4.1.2 Non-Functional Requirements
- 4.1.3 Classification by Requirements Target

4.2 Requirements Elicitation
- 4.2.1 Sources of Requirements Information
- 4.2.2 Customer Presentations
- 4.2.3 Literature Survey
- 4.2.4 Interviews
- 4.2.5 Surveys
- 4.2.6 Brainstorming
- 4.2.7 Prototyping

4.3 Requirements Analysis
- 4.3.1 Requirements Quality
- 4.3.2 Domain Analysis
- 4.3.3 Scenario-Based Analysis

4.4 Use Case
- 4.4.1 Use Case Diagram
- 4.4.2 Use Case Specification
- 4.4.3 Relationships Between Use Cases

4.5 Requirements Specification
- 4.5.1 Writing Methods

4.6 Requirements Validation

**■ Exercises**

### **CHAPTER 05: Requirements Modeling**
5.1 Modeling Basics
- 5.1.1 Perspectives and Levels of Abstraction
- 5.1.2 Software and Modeling
- 5.1.3 Relationships Between Models

5.2 UML
- 5.2.1 History of UML
- 5.2.2 UML Diagrams
- 5.2.3 Modeling Process

5.3 Static Modeling
- 5.3.1 Object-Oriented Concepts
- 5.3.2 Class Diagrams

5.4 Dynamic Modeling
- 5.4.1 Sequence Diagrams
- 5.4.2 Collaboration Diagrams
- 5.4.3 State Diagrams

5.5 Control Modeling

5.6 Model Validation

**■ Exercises**

### **CHAPTER 06: Design Principles**
6.1 Basic Concepts of Design
- 6.1.1 Subsystems, Modules
- 6.1.2 Design Perspectives
- 6.1.3 Design Activities Process

6.2 Quality Goals

6.3 Traditional Design Principles
- 6.3.1 Abstraction
- 6.3.2 Encapsulation
- 6.3.3 Modularity
- 6.3.4 Coupling
- 6.3.5 Cohesion

6.4 Object-Oriented Design Principles
- 6.4.1 Separation of Interface and Implementation
- 6.4.2 Single Responsibility Principle
- 6.4.3 Open/Closed Principle
- 6.4.4 Liskov Substitution Principle
- 6.4.5 Interface Segregation Principle
- 6.4.6 Dependency Inversion Principle

6.5 Design Metrics
- 6.5.1 Traditional Metrics
- 6.5.2 Object-Oriented Metrics

**■ Exercises**

### **CHAPTER 07: Architectural Design and Patterns**
7.1 Basics of Architecture
- 7.1.1 What is Architecture?
- 7.1.2 The Role of Architecture
- 7.1.3 Representation of Architecture

7.2 Architectural Styles
- 7.2.1 Client-Server
- 7.2.2 Layered Architecture
- 7.2.3 Event-Driven Architecture
- 7.2.4 Model-View-Controller (MVC)
- 7.2.5 Pipe and Filter
- 7.2.6 Data-Centered Architecture
- 7.2.7 Peer-to-Peer Style

7.3 Design Patterns
- 7.3.1 Benefits of Design Patterns
- 7.3.2 Format of Design Patterns
- 7.3.3 Singleton Pattern
- 7.3.4 Iterator Pattern
- 7.3.5 Adapter Pattern
- 7.3.6 Decorator Pattern
- 7.3.7 Factory Method Pattern
- 7.3.8 Abstract Factory Pattern
- 7.3.9 State Pattern
- 7.3.10 Observer Pattern

7.4 Architectural Evaluation

**■ Exercises**

### **CHAPTER 08: UI Design**
8.1 Basic Concepts of UI
- 8.1.1 Usability
- 8.1.2 Mental Models
- 8.1.3 Feedback
- 8.1.4 Constraints

8.2 UI Design Principles

8.3 UI Design Process
- 8.3.1 User Analysis
- 8.3.2 Task Analysis
- 8.3.3 UI Design and Implementation
- 8.3.4 Usability Testing

8.4 UI Elements

8.5 Screen and Output Design
- 8.5.1 Screen Design
- 8.5.2 Output Design

**■ Exercises**

### **CHAPTER 09: Coding**
9.1 Coding Activities
- 9.1.1 Process
- 9.1.2 Common Errors

9.2 Coding Standards
- 9.2.1 Naming Conventions
- 9.2.2 Formatting
- 9.2.3 Statements and Expressions
- 9.2.4 Error Handling
- 9.2.5 Comments

9.3 Code Generation from Design
- 9.3.1 Coding Associations
- 9.3.2 Coding Sequence Diagrams

9.4 Refactoring
- 9.4.1 Concept of Refactoring
- 9.4.2 Refactoring Process
- 9.4.3 Code Smells
- 9.4.4 Refactoring Examples

9.5 Code Quality Improvement Techniques
- 9.5.1 Inspection
- 9.5.2 Static Analysis
- 9.5.3 Test-Driven Development

**■ Exercises**

### **CHAPTER 10: Testing**
10.1 Basics of Testing
- 10.1.1 Bugs, Errors, Defects, Failures
- 10.1.2 Principles of Testing
- 10.1.3 Testing Process
- 10.1.4 Test Cases

10.2 Black-Box Testing
- 10.2.1 Equivalence Partitioning Technique
- 10.2.2 Boundary Value Analysis
- 10.2.3 Cause-Effect Graph

10.3 White-Box Testing
- 10.3.1 Representing Logical Flow
- 10.3.2 Verification Criteria

10.4 State-Based Testing

10.5 Integration Testing
- 10.5.1 Big Bang Integration
- 10.5.2 Top-Down Integration
- 10.5.3 Bottom-Up Integration
- 10.5.4 Sandwich Integration

10.6 System and Acceptance Testing
- 10.6.1 Functional Testing
- 10.6.2 Performance Testing
- 10.6.3 Security Testing
- 10.6.4 UI Testing
- 10.6.5 Acceptance Testing

**■ Exercises**

### **CHAPTER 11: Maintenance**
11.1 Introduction to Maintenance
- 11.1.1 Reasons for Change and Types of Maintenance
- 11.1.2 Lehman's Laws

11.2 Maintenance Activities Process
- 11.2.1 Maintenance Tasks
- 11.2.2 Maintenance Process
- 11.2.3 Program Understanding
- 11.2.4 Change Identification and Analysis

11.3 Configuration Management
- 11.3.1 Baselines
- 11.3.2 Configuration Management Procedures

11.4 Reverse Engineering
- 11.4.1 Steps of Reverse Engineering
- 11.4.2 Uses of Reverse Engineering
- 11.4.3 Redocumentation
- 11.4.4 Design Recovery

11.5 Reengineering
- 11.5.1 Purpose of Reengineering
- 11.5.2 Reengineering Process

**■ Exercises**

### **CHAPTER 12: Quality**
12.1 Introduction
- 12.1.1 Concept of Quality
- 12.1.2 Software Quality

12.2 Quality Models

12.3 Quality Management
- 12.3.1 Quality Assurance Organizations
- 12.3.2 Defining Processes and Standards
- 12.3.3 Quality Assurance Activities
- 12.3.4 Inspections

12.4 Quality Measurement
- 12.4.1 Usefulness of Quality Measurement
- 12.4.2 Quality Metrics

12.5 Process Improvement
- 12.5.1 CMMI
- 12.5.2 ISO 9001

**■ Exercises**

## Purpose

The main objective of creating this directory is to aid students in their studies by providing a structured and accessible resource. We hope that by organizing these materials, more students will find it easier to understand and apply the concepts of software engineering in various fields such as computer science, engineering, and more.

---

Thank you for using this resource. We hope it proves to be a valuable aid in your studies. If you have any suggestions or contributions, please feel free to make a pull request or contact us.


